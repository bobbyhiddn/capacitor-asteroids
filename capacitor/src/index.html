<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="color-scheme" content="light dark">
    <title>Asteroids - WebAssembly</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            width: 100%;
            height: 100dvh; /* Use dynamic viewport height */
            background-color: #000000;
            color-scheme: dark;
        }

        body {
            width: 100%;
            height: 100dvh;
            position: fixed;
            overflow: hidden;
            margin: 0;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #000000;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background-color: #000000;
        }

        canvas {
            position: absolute;
            background-color: #000000;
            touch-action: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        @supports (-webkit-touch-callout: none) {
            /* iOS-specific fixes */
            html, body {
                height: -webkit-fill-available;
            }
            
            #canvas-container {
                height: -webkit-fill-available;
            }
        }

        /* Prevent pull-to-refresh on mobile browsers */
        @media (pointer: coarse) {
            body {
                overflow: hidden;
                overscroll-behavior: none;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // Global error handler
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Window Error:', {msg, url, lineNo, columnNo, error});
            alert(`Error: ${msg}\nLine: ${lineNo}\nDetails: ${error}`);
            return false;
        };

        // Asset path helper
        function getAssetPath(filename) {
            return `assets/${filename}`;
        }

        let initializationAttempts = 0;
        const MAX_ATTEMPTS = 3;

        async function initializeWebAssembly() {
            console.log('Starting WebAssembly initialization...');
            
            if (!WebAssembly.instantiateStreaming) {
                console.log('WebAssembly.instantiateStreaming not available, using polyfill');
                WebAssembly.instantiateStreaming = async (resp, importObject) => {
                    const source = await (await resp).arrayBuffer();
                    return await WebAssembly.instantiate(source, importObject);
                };
            }

            try {
                const go = new Go();
                const wasmPath = getAssetPath('game.wasm');
                console.log('Environment:', {
                    isCapacitor: !!window.Capacitor,
                    wasmPath,
                    documentPath: document.location.href
                });
                
                const response = await fetch(wasmPath);
                if (!response.ok) {
                    throw new Error(`Failed to fetch WASM file: ${response.status} ${response.statusText}`);
                }
                
                console.log('WASM file fetched successfully, instantiating...');
                const result = await WebAssembly.instantiateStreaming(response, go.importObject);
                console.log('WebAssembly instantiated successfully, starting game...');
                
                // Update canvas size before starting the game
                updateCanvasSize();
                
                try {
                    await go.run(result.instance);
                } catch (runError) {
                    console.error('Error running WebAssembly:', runError);
                    throw runError;
                }
            } catch (err) {
                console.error('Detailed error:', {
                    message: err.message,
                    stack: err.stack,
                    name: err.name,
                    cause: err.cause
                });
                
                if (initializationAttempts < MAX_ATTEMPTS) {
                    initializationAttempts++;
                    console.log(`Retrying initialization (attempt ${initializationAttempts}/${MAX_ATTEMPTS})...`);
                    setTimeout(initializeWebAssembly, 1000);
                } else {
                    console.error('Failed to initialize after maximum attempts');
                    alert('Failed to load game. Please check the console for details.');
                }
            }
        }

        function updateCanvasSize() {
            const canvas = document.getElementById('canvas');
            if (!canvas) {
                console.error('Canvas element not found');
                return;
            }
            const container = document.getElementById('canvas-container');
            if (!container) {
                console.error('Canvas container not found');
                return;
            }
            
            console.log('Updating canvas size...');
            
            // Reset canvas style
            canvas.style.cssText = '';
            
            // Get viewport size
            const viewport = getViewportSize();
            const containerWidth = viewport.width;
            const containerHeight = viewport.height;
            
            // Set internal resolution
            canvas.width = 800;
            canvas.height = 600;
            
            // Calculate scaling
            const isLandscape = containerWidth > containerHeight;
            let targetWidth, targetHeight;
            
            if (isLandscape) {
                targetHeight = containerHeight;
                targetWidth = targetHeight * (4/3);
                
                if (targetWidth > containerWidth) {
                    targetWidth = containerWidth;
                    targetHeight = targetWidth * (3/4);
                }
            } else {
                targetWidth = containerWidth;
                targetHeight = targetWidth * (3/4);
                
                if (targetHeight > containerHeight) {
                    targetHeight = containerHeight;
                    targetWidth = targetHeight * (4/3);
                }
            }
            
            // Apply dimensions with transform for better performance
            targetWidth = Math.floor(targetWidth);
            targetHeight = Math.floor(targetHeight);
            
            canvas.style.width = targetWidth + 'px';
            canvas.style.height = targetHeight + 'px';
            
            // Center using transform instead of left/top
            const translateX = (containerWidth - targetWidth) / 2;
            const translateY = (containerHeight - targetHeight) / 2;
            canvas.style.transform = `translate(${translateX}px, ${translateY}px)`;
            
            // Log the final dimensions
            console.log('Canvas dimensions set to:', {
                width: canvas.width,
                height: canvas.height,
                styleWidth: canvas.style.width,
                styleHeight: canvas.style.height
            });
        }

        function getViewportSize() {
            const vh = window.innerHeight;
            const vw = window.innerWidth;
            // Some browsers include UI elements in innerHeight, use documentElement if available
            const docHeight = document.documentElement.clientHeight;
            return {
                width: vw,
                height: Math.min(vh, docHeight)
            };
        }

        // Wait for both DOM and wasm_exec.js to be loaded before initializing
        const domLoaded = new Promise(resolve => {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', resolve);
            } else {
                resolve();
            }
        });

        const wasmExecLoaded = new Promise(resolve => {
            if (window.Go) {
                resolve();
            } else {
                const script = document.createElement('script');
                script.src = getAssetPath('wasm_exec.js');
                script.onload = resolve;
                script.onerror = (e) => console.error('Failed to load wasm_exec.js:', e);
                document.head.appendChild(script);
            }
        });

        // Only initialize when everything is ready
        Promise.all([domLoaded, wasmExecLoaded])
            .then(() => {
                console.log('DOM and wasm_exec.js loaded, proceeding with initialization');
                setTimeout(initializeWebAssembly, 100);
            })
            .catch(error => console.error('Error during initialization:', error));
    </script>
</body>
</html>